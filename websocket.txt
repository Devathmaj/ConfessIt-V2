File: /home/devat/ConfessIt (V2)/backend/app/main.py

# app/main.py

from fastapi import FastAPI, Depends, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from .routers import auth, profile, matchmaking, confessions, love_notes, conversations
from .services.auth_service import get_current_user
from .dependencies import get_db 
from pymongo.database import Database
import uvicorn
import pymongo
from .config import settings
from .models import UserDetails
from .logger import get_logger
from .websocket_manager import handle_websocket_connection, check_and_broadcast_expiry_warnings
import asyncio

# Initialize logger
logger = get_logger(__name__)

app = FastAPI(
    title="ConfessIt API",
    description="Backend for the anonymous confession and matchmaking application.",
    version="0.1.0"
)
# ... (code omitted for brevity)
# ----------------------
# WebSocket Endpoints
# ----------------------
@app.websocket("/ws/{match_id}")
async def websocket_endpoint(websocket: WebSocket, match_id: str):
    """WebSocket endpoint for real-time messaging in a specific match"""
    try:
        # Get user from query parameters (token-based auth for WebSocket)
        token = websocket.query_params.get("token")
        if not token:
            await websocket.close(code=4001, reason="Missing authentication token")
            return
        
        # Validate token and get user
        try:
            user = get_current_user(token)
            user_id = user["Regno"]
        except Exception as e:
            logger.error(f"Invalid token for WebSocket connection: {e}")
            await websocket.close(code=4001, reason="Invalid authentication token")
            return
        
        # Handle the WebSocket connection
        await handle_websocket_connection(websocket, user_id, match_id)
        
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected")
    except Exception as e:
        logger.error(f"Error in WebSocket endpoint: {e}")
        try:
            await websocket.close(code=4000, reason="Internal server error")
        except:
            pass
---
File: /home/devat/ConfessIt (V2)/backend/app/routers/conversations.py

# app/routers/conversations.py

from fastapi import APIRouter, Depends, status
from pymongo.database import Database
from typing import Annotated

from ..dependencies import get_db
from ..models import UserDetails, ConversationCreate
from ..services.auth_service import get_current_user
from ..services.conversation_service import (
    request_conversation_service,
    get_conversation_status_service,
    accept_conversation_service,
    send_message_service,
    get_current_conversation_service,
    reject_conversation_service,
    get_conversation_messages_service
)

router = APIRouter(
    prefix="/conversations",
    tags=["Conversations"]
)
# ... (code omitted for brevity)
---
File: /home/devat/ConfessIt (V2)/backend/app/websocket_manager.py

# app/websocket_manager.py

import json
import asyncio
from typing import Dict, Set, Optional
from fastapi import WebSocket, WebSocketDisconnect
from datetime import datetime, timezone
# Import these as functions to avoid circular imports
from .services.matchmaking_service import get_active_matches
from .dependencies import get_db
from .logger import get_logger

logger = get_logger(__name__)

class ConnectionManager:
    def __init__(self):
        # Map of match_id -> set of WebSocket connections
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        # Map of user_id -> set of WebSocket connections (for user-specific messages)
        self.user_connections: Dict[str, Set[WebSocket]] = {}
        # Map of WebSocket -> user_id for cleanup
        self.websocket_users: Dict[WebSocket, str] = {}
        # Map of WebSocket -> match_id for cleanup
        self.websocket_matches: Dict[WebSocket, str] = {}
        
    async def connect(self, websocket: WebSocket, user_id: str, match_id: str):
        await websocket.accept()
        
        # Add to match connections
        if match_id not in self.active_connections:
            self.active_connections[match_id] = set()
        self.active_connections[match_id].add(websocket)
        
        # Add to user connections
        if user_id not in self.user_connections:
            self.user_connections[user_id] = set()
        self.user_connections[user_id].add(websocket)
        
        # Track for cleanup
        self.websocket_users[websocket] = user_id
        self.websocket_matches[websocket] = match_id
        
        logger.info(f"User {user_id} connected to match {match_id}")
        
    def disconnect(self, websocket: WebSocket):
        # Remove from match connections
        match_id = self.websocket_matches.get(websocket)
        if match_id and match_id in self.active_connections:
            self.active_connections[match_id].discard(websocket)
            if not self.active_connections[match_id]:
                del self.active_connections[match_id]
        
        # Remove from user connections
        user_id = self.websocket_users.get(websocket)
        if user_id and user_id in self.user_connections:
            self.user_connections[user_id].discard(websocket)
            if not self.user_connections[user_id]:
                del self.user_connections[user_id]
        
        # Clean up tracking
        self.websocket_users.pop(websocket, None)
        self.websocket_matches.pop(websocket, None)
        
        if user_id and match_id:
            logger.info(f"User {user_id} disconnected from match {match_id}")
    
    async def send_personal_message(self, message: dict, websocket: WebSocket):
        try:
            await websocket.send_text(json.dumps(message))
        except Exception as e:
            logger.error(f"Error sending personal message: {e}")
            self.disconnect(websocket)
    
    async def broadcast_to_match(self, message: dict, match_id: str, exclude_websocket: Optional[WebSocket] = None):
        if match_id not in self.active_connections:
            return
        
        disconnected_websockets = set()
        
        for websocket in self.active_connections[match_id]:
            if websocket != exclude_websocket:
                try:
                    await websocket.send_text(json.dumps(message))
                except Exception as e:
                    logger.error(f"Error broadcasting to match {match_id}: {e}")
                    disconnected_websockets.add(websocket)
        
        # Clean up disconnected websockets
        for websocket in disconnected_websockets:
            self.disconnect(websocket)
    
    async def broadcast_to_user(self, message: dict, user_id: str, exclude_websocket: Optional[WebSocket] = None):
        if user_id not in self.user_connections:
            return
        
        disconnected_websockets = set()
        
        for websocket in self.user_connections[user_id]:
            if websocket != exclude_websocket:
                try:
                    await websocket.send_text(json.dumps(message))
                except Exception as e:
                    logger.error(f"Error broadcasting to user {user_id}: {e}")
                    disconnected_websockets.add(websocket)
        
        # Clean up disconnected websockets
        for websocket in disconnected_websockets:
            self.disconnect(websocket)

# Global connection manager instance
manager = ConnectionManager()

async def handle_websocket_connection(websocket: WebSocket, user_id: str, match_id: str):
    """Handle WebSocket connection for a user in a specific match"""
    await manager.connect(websocket, user_id, match_id)
    
    try:
        # Send initial connection confirmation
        await manager.send_personal_message({
            "type": "connection_established",
            "user_id": user_id,
            "match_id": match_id,
            "timestamp": datetime.now(timezone.utc).isoformat()
        }, websocket)
        
        # Keep connection alive and handle incoming messages
        while True:
            try:
                # Wait for messages from client
                data = await websocket.receive_text()
                message_data = json.loads(data)
                
                # Handle different message types
                message_type = message_data.get("type")
                
                if message_type == "ping":
                    # Respond to ping with pong
                    await manager.send_personal_message({
                        "type": "pong",
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    }, websocket)
                
                elif message_type == "typing":
                    # Broadcast typing indicator to other users in the match
                    await manager.broadcast_to_match({
                        "type": "typing",
                        "user_id": user_id,
                        "match_id": match_id,
                        "is_typing": message_data.get("is_typing", False),
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    }, match_id, exclude_websocket=websocket)
                
                elif message_type == "message_sent":
                    # This is just a notification that a message was sent via REST API
                    # The actual message will be broadcasted when the REST API calls broadcast_new_message
                    await manager.send_personal_message({
                        "type": "message_confirmed",
                        "message_id": message_data.get("message_id"),
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    }, websocket)
                
            except WebSocketDisconnect:
                logger.info(f"WebSocket disconnected for user {user_id} in match {match_id}")
                break
            except json.JSONDecodeError:
                logger.error(f"Invalid JSON received from user {user_id}")
                continue
            except Exception as e:
                logger.error(f"Error handling WebSocket message from user {user_id}: {e}")
                break
                
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for user {user_id} in match {match_id}")
    except Exception as e:
        logger.error(f"Error in WebSocket connection for user {user_id}: {e}")
    finally:
        manager.disconnect(websocket)
---
File: /home/devat/ConfessIt (V2)/frontend/src/services/websocket.ts

// services/websocket.ts

export interface WebSocketMessage {
  type: string;
  [key: string]: any;
}

export interface NewMessageData {
  id: string;
  text: string;
  sender_id: string;
  receiver_id: string;
  timestamp: string;
  is_sender: boolean;
}

export interface ConversationStatusData {
  status: 'accepted' | 'rejected' | 'expired';
  accepted_by?: string;
  accepted_at?: string;
  rejected_by?: string;
  rejected_at?: string;
  reason?: string;
}

export interface TypingData {
  user_id: string;
  match_id: string;
  is_typing: boolean;
  timestamp: string;
}

export interface MatchExpiryData {
  match_id: string;
  time_left_seconds: number;
  timestamp: string;
}

class WebSocketService {
  private ws: WebSocket | null = null;
  private matchId: string | null = null;
  private token: string | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000; // Start with 1 second
  private messageHandlers: Map<string, ((data: any) => void)[]> = new Map();
  private isConnecting = false;
  private pingInterval: NodeJS.Timeout | null = null;
  private pongTimeout: NodeJS.Timeout | null = null;

  constructor() {
    // Get token from localStorage
    this.token = localStorage.getItem('token');
  }

  connect(matchId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.isConnecting) {
        reject(new Error('Connection already in progress'));
        return;
      }

      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        if (this.matchId === matchId) {
          resolve(); // Already connected to the same match
          return;
        } else {
          this.disconnect(); // Disconnect from previous match
        }
      }

      this.isConnecting = true;
      this.matchId = matchId;

      if (!this.token) {
        reject(new Error('No authentication token available'));
        this.isConnecting = false;
        return;
      }

      const wsUrl = `ws://localhost:8001/ws/${matchId}?token=${this.token}`;
      
      try {
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
          console.log(`WebSocket connected to match ${matchId}`);
          this.isConnecting = false;
          this.reconnectAttempts = 0;
          this.reconnectDelay = 1000;
          this.startPingInterval();
          resolve();
        };

        this.ws.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data);
            this.handleMessage(message);
          } catch (error) {
            console.error('Error parsing WebSocket message:', error);
          }
        };

        this.ws.onclose = (event) => {
          console.log(`WebSocket disconnected from match ${matchId}:`, event.code, event.reason);
          this.isConnecting = false;
          this.stopPingInterval();
          
          // Attempt to reconnect if not a normal closure
          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.scheduleReconnect();
          }
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.isConnecting = false;
          reject(error);
        };

      } catch (error) {
        this.isConnecting = false;
        reject(error);
      }
    });
  }

  disconnect(): void {
    this.stopPingInterval();
    
    if (this.ws) {
      this.ws.close(1000, 'Normal closure');
      this.ws = null;
    }
    
    this.matchId = null;
    this.reconnectAttempts = 0;
  }

  private scheduleReconnect(): void {
    this.reconnectAttempts++;
    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);
    
    console.log(`Scheduling WebSocket reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    setTimeout(() => {
      if (this.matchId) {
        this.connect(this.matchId).catch(error => {
          console.error('Reconnect failed:', error);
        });
      }
    }, delay);
  }

  private startPingInterval(): void {
    this.pingInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.sendMessage({
          type: 'ping',
          timestamp: new Date().toISOString()
        });
        
        // Set pong timeout
        this.pongTimeout = setTimeout(() => {
          console.warn('Pong timeout - reconnecting WebSocket');
          this.disconnect();
          if (this.matchId) {
            this.connect(this.matchId);
          }
        }, 5000); // 5 second timeout
      }
    }, 30000); // Send ping every 30 seconds
  }

  private stopPingInterval(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
    
    if (this.pongTimeout) {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = null;
    }
  }

  sendMessage(message: WebSocketMessage): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket is not connected, cannot send message:', message);
    }
  }

  sendTypingIndicator(isTyping: boolean): void {
    this.sendMessage({
      type: 'typing',
      is_typing: isTyping,
      timestamp: new Date().toISOString()
    });
  }

  sendMessageSentNotification(messageId: string): void {
    this.sendMessage({
      type: 'message_sent',
      message_id: messageId,
      timestamp: new Date().toISOString()
    });
  }

  private handleMessage(message: WebSocketMessage): void {
    console.log('Received WebSocket message:', message);
    
    // Handle pong messages
    if (message.type === 'pong') {
      if (this.pongTimeout) {
        clearTimeout(this.pongTimeout);
        this.pongTimeout = null;
      }
      return;
    }
    
    // Handle connection established
    if (message.type === 'connection_established') {
      console.log('WebSocket connection established for match:', message.match_id);
      return;
    }
    
    // Handle message confirmation
    if (message.type === 'message_confirmed') {
      console.log('Message confirmed:', message.message_id);
      return;
    }
    
    // Notify handlers
    const handlers = this.messageHandlers.get(message.type);
    if (handlers) {
      console.log(`Notifying ${handlers.length} handlers for message type: ${message.type}`);
      handlers.forEach(handler => {
        try {
          handler(message);
        } catch (error) {
          console.error(`Error in message handler for type ${message.type}:`, error);
        }
      });
    } else {
      console.log(`No handlers found for message type: ${message.type}`);
    }
  }

  onMessage(type: string, handler: (data: any) => void): () => void {
    if (!this.messageHandlers.has(type)) {
      this.messageHandlers.set(type, []);
    }
    
    this.messageHandlers.get(type)!.push(handler);
    
    // Return unsubscribe function
    return () => {
      const handlers = this.messageHandlers.get(type);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
        }
        if (handlers.length === 0) {
          this.messageHandlers.delete(type);
        }
      }
    };
  }

  onNewMessage(handler: (data: { message: NewMessageData; match_id: string; timestamp: string }) => void): () => void {
    console.log('Subscribing to new_message WebSocket events');
    return this.onMessage('new_message', handler);
  }

  onConversationStatusUpdate(handler: (data: { status: ConversationStatusData; match_id: string; timestamp: string }) => void): () => void {
    return this.onMessage('conversation_status_update', handler);
  }

  onTyping(handler: (data: TypingData) => void): () => void {
    return this.onMessage('typing', handler);
  }

  onMatchExpiryWarning(handler: (data: MatchExpiryData) => void): () => void {
    return this.onMessage('match_expiry_warning', handler);
  }

  onMatchExpired(handler: (data: { match_id: string; timestamp: string }) => void): () => void {
    return this.onMessage('match_expired', handler);
  }

  isConnected(): boolean {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }

  getMatchId(): string | null {
    return this.matchId;
  }
}

// Export singleton instance
export const websocketService = new WebSocketService();
